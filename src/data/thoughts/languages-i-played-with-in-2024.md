---
title: languages I played with in 2024
date: 2024-12-25
description: Yes, *played with*, so please don't take anything I say too seriously.
tags:
  [
    gleam,
    rust,
    elixir,
    ocaml,
    rescript,
    scala,
    haskell,
    purescript,
    lean,
    unison,
  ]
draft: false
modifiedDate: 2024-12-25
slug: languages-in-2024
---

**`gleam`**

Nice, simple language with stellar tooling. Still very young, interested to see where it goes!

**`rust`**

Nice, complicated language with stellar tooling. Got further into it _this time round_ (stressed myself out learning it prior), but stopped at macros? concurrency? (the hard stuff). Probably overkill for me, personally.

**`elixir`**

First eye-opener was pattern matching _directly_ in the function's parameter list - quite a nice alternative to writing explicit control flow. Wasn't a huge fan of the numerous data structures (when do I use maps vs keyword lists?) and I found some of the syntax hard to remember (when do I use arrows? atoms? colons). I know some of these questions have straightforward answers, but it wasn't immediately intuitive and I don't like having to keep that kind of stuff in the forefront of my brain. Not a huge fan of some parts of the API being seemingly "inconsistent" (due to Erlang, but I know Erlang interop is supposed to one of the best parts?)

**`ocaml`**

I hate it and can't seem to get into it. Resources are kind of scarce, the ecosystem seems like a mess

**`rescript`**

On its own, the language (well, dialect) seems ok, but docs aren't quite there yet - hit a roadblock when I actually tried to start a React project with it (asked me to run `Demo.mjs` or something but the npx scaffolding doesn't even create one). Unless I read something in the docs incorrectly, but I'm fairly certain I didn't. (Also, why is there `Belt` vs `Js` vs `Core`...)

_update (2024-01-03): never mind, I suck at reading docs_

**`scala`**

Man, idk. I really, really wish I liked this one, if only for the fact that there seem to be so many FP resources for it. Unfortunately, it seems like Scala 2 -> 3 was a huge jump, and many of those resources are written for Scala 2. Even _the official resources_ are guilty of this - often I'll search for something, click on the link, and it'll have a link saying "There's an updated version of this page". Kind of annoying.

_update (2024-01-03): never mind, I'll give it another go_

**`haskell`**

_Struggled_ with the tooling. Can't count how many times I had to `ghc nuke`. Re: the language itself - this one will probably be a years-long endeavour. Currently on hold, in favor of:

_update (2024-01-03): never mind, Haskell (and by extension, Purescript) is really, really hard and it'll take me forever to get anywhere with this language (I got up to monad transformers and things have stopped making sense. Also, what is up with the record story in Haskell?). Treating it as an academic exercise has not worked, and things are not fun anymore. Maybe one day..._

**`purescript`**

Also struggled with this one at first. The documentation is kind of scarce - I hope one day, every language has a tutorial in the form of "a tour of". But, I landed on a book I'm enjoying, and things are... progressing. The error messages from the compiler seem slightly more helpful than Haskell's, so the _feedback loop is just better_. I'm enjoying it, and may head back to learn Haskell properly when this is done

**`lean`**

_AMAZING_, amazing dx. The interactive development is just _chefs kiss_. I doubt I'll end up getting anything done with this one, since most of its use cases seem to be mostly academic in nature, but I'll keep my eye on it for sure.

**`unison`**

Seems really interesting? The development workflow is a huge paradigm shift. Probably won't ever have a need for the distributed code management but I'll definitely keep watching this one too.
